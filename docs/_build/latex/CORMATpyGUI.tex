% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\else\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{CORMATpy  GUI Documentation}
\date{Jun 03, 2019}
\release{0.0.13}
\author{Bruno Viola}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Project Summary}
\label{project:cormatpy-gui-documentation}\label{project:project-summary}\label{project::doc}
This GUI is meant to be an useful tool for the KG1 responsible officer or
anybody else with rights to operate with JET interpherometer related data (i.e.
must have rights to write public ppf and access data)


\chapter{Tutorial}
\label{tutorial:tutorial}\label{tutorial::doc}
In this section I will explain how to use the tool and what is possible to
achieve.


\section{Installation process}
\label{tutorial:installation-process}
To run and use the code the user must first install it and all its dependacies.

The code is stored in a git repository

from terminal
\begin{quote}

\textgreater{}\textgreater{} git clone \href{mailto:git@git.ccfe.ac.uk}{git@git.ccfe.ac.uk}:bviola/Cormat\_py.git -b master /your/folder
\end{quote}


\section{Running the code from Terminal}
\label{tutorial:running-the-code-from-terminal}\begin{description}
\item[{To tun the code::}] \leavevmode
cd /u/username/work/
python Cormat\_main.py -h

usage: Cormat\_main.py {[}-h{]} {[}-d DEBUG{]} {[}-doc DOCUMENTATION{]}

Run Cormat\_main

optional arguments:
-h, --help            show this help message and exit
-d DEBUG, --debug DEBUG
Debug level. 0: Info, 1: Warning, 2: Debug, 3: Error, 4: Debug plus;
default level is INFO

\end{description}

Alternatively is possible to run the code specifying the debug level to
increase verbosity and show debug/warning/error messages.

By default the debug level is \textbf{INFO}

Once run an itialization process begins:
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{Initialisation}.png}
\caption{Initialisation process}\label{tutorial:id1}\end{figure}

The code will check if is running in an 64bit enviroment with Python3. It will also check what user is running the code and if it has proper authorisation to write KG1 public ppfs.
If not, the user will be able to run the code but he/she will be limited in writing only private ppfs.

If the user has chosen so, during the initialisation process also the documentation can be produced (updated).

After the inialization process, if finished successfully, the user will be prompted with the GUI:
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{main_windows}.png}
\caption{Main GUI}\label{tutorial:id2}\end{figure}

Window size will be scaled to dimension of screen resolution.
It is advisable to scale a bit the dimension of the window to read messages on terminal even though all messages will be displayed as well inside the GUI.


\section{Using the code}
\label{tutorial:using-the-code}
After chosing a pulse
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{input}.png}
\caption{Pulse selection}\label{tutorial:id3}\end{figure}

The user can use the drop down menu in Figure to choose the read\_uid
The list that is shown here contains all user that are authorised to write KG1 public ppf.
After clicking the load button, the code  start running according to:
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{load_button_new}.png}
\caption{Load button logic}\label{tutorial:id4}\end{figure}

After loading a pulse the user now will have to choose a pulse to validate.
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{data_plotted}.png}
\caption{Pulse selection}\label{tutorial:id5}\end{figure}


\chapter{Main control function}
\label{control:main-control-function}\label{control::doc}

\section{Cormat\_main module}
\label{Cormat_main:cormat-main-module}\label{Cormat_main::doc}\phantomsection\label{Cormat_main:module-Cormat_main}\index{Cormat\_main (module)}
Class that runs CORMAT\_py GUI
\index{myself() (in module Cormat\_main)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.myself}\pysiglinewithargsret{\code{Cormat\_main.}\bfcode{myself}}{}{}
\end{fulllineitems}

\index{CORMAT\_GUI (class in Cormat\_main)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI}\pysiglinewithargsret{\strong{class }\code{Cormat\_main.}\bfcode{CORMAT\_GUI}}{\emph{parent=None}}{}
Bases: \code{PyQt4.QtGui.QMainWindow}, {\hyperref[CORMAT_GUI:CORMAT_GUI.Ui_CORMAT_py]{\crossref{\code{CORMAT\_GUI.Ui\_CORMAT\_py}}}}, {\hyperref[custom_formatters:custom_formatters.QPlainTextEditLogger]{\crossref{\code{custom\_formatters.QPlainTextEditLogger}}}}

Main control function for CORMATpy GUI.
\index{handle\_readbutton\_master() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_readbutton_master}\pysiglinewithargsret{\bfcode{handle\_readbutton\_master}}{}{}
implemets what happen when clicking the load button on the GUI
the logic is explained in the FLowDiagram ../FlowDiagram/load\_button\_new.dia

\end{fulllineitems}

\index{checkStatuFlags() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.checkStatuFlags}\pysiglinewithargsret{\bfcode{checkStatuFlags}}{}{}
reads the list containing pulse status flag
:return:

\end{fulllineitems}

\index{canvasselected() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.canvasselected}\pysiglinewithargsret{\bfcode{canvasselected}}{\emph{arg=None}}{}
function that convert arg number into tab name
it also sets the SF value when changing tabs
:param arg: index of canvas
:return:

\end{fulllineitems}

\index{setcoord() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.setcoord}\pysiglinewithargsret{\bfcode{setcoord}}{\emph{chan}, \emph{reset=False}}{}
connects selected tab to its own list of selected data points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{reset}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{checkstate() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.checkstate}\pysiglinewithargsret{\bfcode{checkstate}}{\emph{button}}{}
connect tab number to LID channel and sets status flag
it also performs a check if the user clicked a radio button to change status flag for current tab/channel
:param button:
:return:

\end{fulllineitems}

\index{set\_status\_flag\_radio() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.set_status_flag_radio}\pysiglinewithargsret{\bfcode{set\_status\_flag\_radio}}{\emph{value}}{}
converts status flag integer value into boolean to check SF radio buttons in GUI
:param value: status flag to be applied to selected channel
:return:

\end{fulllineitems}

\index{load\_pickle() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.load_pickle}\pysiglinewithargsret{\bfcode{load\_pickle}}{}{}
loads last saved data from non saved operations
data are saved in pickle format (binary)

also to be used when reloading a pulse

\end{fulllineitems}

\index{save\_to\_pickle() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.save_to_pickle}\pysiglinewithargsret{\bfcode{save\_to\_pickle}}{\emph{folder}}{}
saves to pickle experimental data
:param folder: for now user can save either to saved or scratch folder
:return:

\end{fulllineitems}

\index{save\_kg1() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.save_kg1}\pysiglinewithargsret{\bfcode{save\_kg1}}{\emph{folder}}{}
module that saves just kg1 data to folder
:param folder:
:return:

\end{fulllineitems}

\index{dump\_kg1() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.dump_kg1}\pysiglinewithargsret{\bfcode{dump\_kg1}}{}{}
temporary save kg1 data to scratch folder
:return:

\end{fulllineitems}

\index{handle\_no() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_no}\pysiglinewithargsret{\bfcode{handle\_no}}{}{}
functions that ask to confirm if user wants NOT to proceed

to set read data for selected pulse

\end{fulllineitems}

\index{handle\_yes() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_yes}\pysiglinewithargsret{\bfcode{handle\_yes}}{}{}
functions that ask to confirm if user wants to proceed

to set read data for selected pulse

\end{fulllineitems}

\index{handle\_yes\_reload() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_yes_reload}\pysiglinewithargsret{\bfcode{handle\_yes\_reload}}{}{}
module that handles readloading already downloaded data
:return:

\end{fulllineitems}

\index{readdata() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.readdata}\pysiglinewithargsret{\bfcode{readdata}}{}{}
function that reads data as described in const.ini
:return: True if success
\begin{quote}

False if error
saves data to pickle files: one just for KG1 (kg1\_data) and one for everything else (data.pkl)
\end{quote}

\end{fulllineitems}

\index{plot\_data() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.plot_data}\pysiglinewithargsret{\bfcode{plot\_data}}{}{}
handles widgets
initialises canvas to blank
sets grid and axes
plots KG1 data
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{GUI\_refresh() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.GUI_refresh}\pysiglinewithargsret{\bfcode{GUI\_refresh}}{}{}
updates GUI after reading data
enables/disables buttons

connects tab to tabselected signal

finally run a check on status flag applied to selected channel
:return:

\end{fulllineitems}

\index{update\_channel() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.update_channel}\pysiglinewithargsret{\bfcode{update\_channel}}{\emph{chan}}{}
after a correction is applied this module updates kg1 data to new values
and replots data on all tabs
:param chan:
:return:

\end{fulllineitems}

\index{set\_xlimits() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.set_xlimits}\pysiglinewithargsret{\bfcode{set\_xlimits}}{\emph{lower}, \emph{upper}}{}
Convenience method to canvas.axes.set\_xlim
as matplotlib autoupdate is bugged
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{lower}} -- lower limit of data

\item {} 
\textbf{\texttt{upper}} -- upper limit of data

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_2nd\_trace() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.plot_2nd_trace}\pysiglinewithargsret{\bfcode{plot\_2nd\_trace}}{}{}
function that plots a second trace in the tabs(each canvas)
at the moment clears the canvas and re-plot everything
so probably a little slow.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_markers() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.plot_markers}\pysiglinewithargsret{\bfcode{plot\_markers}}{}{}
function that plots a marker traces in the tabs(each canvas)
This version creates sub plot inside the canvas
:return:

\end{fulllineitems}

\index{handle\_check\_status() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_check_status}\pysiglinewithargsret{\bfcode{handle\_check\_status}}{\emph{button\_newpulse}}{}
function used for debugging and control purposes -
-
checks if button ``newpulse'' is clicked
:param button\_newpulse:
:return: disable/enable combobox

\end{fulllineitems}

\index{handle\_saveppfbutton() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_saveppfbutton}\pysiglinewithargsret{\bfcode{handle\_saveppfbutton}}{}{}
save data

user will save either Status Flags or ppf (and SF)

if user selects in GUI to save ppf a new PPF sequence will be written for dda='KG1V'
if user selects in GUI to save SF only the SF will be written in the last sequence (no new sequence)

is data is has not been modified it automatically switches to save status flags only

as from May 2019 there is a bug in ppfssr so a new ppf will written in either cases.

\end{fulllineitems}

\index{handle\_save\_data\_statusflag() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_save_data_statusflag}\pysiglinewithargsret{\bfcode{handle\_save\_data\_statusflag}}{}{}
function data handles the writing of a new PPF
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
67 if there has been an error in writing status flag
0 otherwise (success)

\end{description}\end{quote}

\end{fulllineitems}

\index{handle\_save\_statusflag() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_save_statusflag}\pysiglinewithargsret{\bfcode{handle\_save\_statusflag}}{}{}
function that uses ppfssf inside ppf library (ATTENTION this function is not listed yet in the ppf library python documentation (only C++ version)
:return: 0 if success
\begin{quote}

68 if fails to write status flags
\end{quote}

\end{fulllineitems}

\index{handle\_normalizebutton() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_normalizebutton}\pysiglinewithargsret{\bfcode{handle\_normalizebutton}}{}{}
function that normalises the second trace to KG1 for comparing purposes during validation and fringe correction
:return:

\end{fulllineitems}

\index{handle\_button\_restore() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_button_restore}\pysiglinewithargsret{\bfcode{handle\_button\_restore}}{}{}
function that restores signals to original amplitude
:return:

\end{fulllineitems}

\index{handle\_makepermbutton() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_makepermbutton}\pysiglinewithargsret{\bfcode{handle\_makepermbutton}}{}{}
function that makes permanent last correction
store data into FC dtype only
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{check\_current\_tab() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.check_current_tab}\pysiglinewithargsret{\bfcode{check\_current\_tab}}{}{}
returns current tab
:return: current tab

\end{fulllineitems}

\index{keyPressEvent() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.keyPressEvent}\pysiglinewithargsret{\bfcode{keyPressEvent}}{\emph{event}}{}
keyboard events that enable actions are:

. starts single correction mode
m stats multiple correction mode
starts zeroing
n starts neutralisation mode
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{event}} -- keyboard event

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{handle\_help\_menu() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_help_menu}\pysiglinewithargsret{\bfcode{handle\_help\_menu}}{}{}
opens Chrome browser to read HTML documentation
:return:

\end{fulllineitems}

\index{handle\_pdf\_open() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_pdf_open}\pysiglinewithargsret{\bfcode{handle\_pdf\_open}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
opens pdf file of the guide

\end{description}\end{quote}

\end{fulllineitems}

\index{multiplecorrections() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.multiplecorrections}\pysiglinewithargsret{\bfcode{multiplecorrections}}{}{}
this module applies multiple corrections (same fringe correction) to selected channel
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{zeroingcorrection() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.zeroingcorrection}\pysiglinewithargsret{\bfcode{zeroingcorrection}}{}{}
this module zeroes correction on selected channel
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{neutralisatecorrections() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.neutralisatecorrections}\pysiglinewithargsret{\bfcode{neutralisatecorrections}}{}{}
module that neutralises permanent corretions

first the code will process manual corrections not made permanent yet

then the code will process automatic corrections produced by hardware and stored inside KG1V/FCx
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{suggestcorrection() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.suggestcorrection}\pysiglinewithargsret{\bfcode{suggestcorrection}}{}{}
module that suggests correction to apply on selected point
:return:

\end{fulllineitems}

\index{getcorrectionpointwidget() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.getcorrectionpointwidget}\pysiglinewithargsret{\bfcode{getcorrectionpointwidget}}{}{}
action to perform when the single correction signal is emitted:
each widget (canvas) is connected to the function that gets data point from canvas

and shows widget to apply correction
:return:

\end{fulllineitems}

\index{getmultiplecorrectionpointswidget() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.getmultiplecorrectionpointswidget}\pysiglinewithargsret{\bfcode{getmultiplecorrectionpointswidget}}{}{}
action to perform when the single correction signal is emitted:
each widget (canvas) is connected to the function that gets data point from canvas

and shows widget to apply correction
:return:

\end{fulllineitems}

\index{disconnnet\_multiplecorrectionpointswidget() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.disconnnet_multiplecorrectionpointswidget}\pysiglinewithargsret{\bfcode{disconnnet\_multiplecorrectionpointswidget}}{}{}
action to perform when the single correction signal is emitted:
each widget (canvas) is connected to the function that gets data point from canvas

and shows widget to apply correction
:return:

\end{fulllineitems}

\index{gettotalcorrections() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.gettotalcorrections}\pysiglinewithargsret{\bfcode{gettotalcorrections}}{}{}
\end{fulllineitems}

\index{singlecorrection() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.singlecorrection}\pysiglinewithargsret{\bfcode{singlecorrection}}{}{}
this module applies single correction to selected channel
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_point() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.get_point}\pysiglinewithargsret{\bfcode{get\_point}}{}{}
each tab as its own vector where input data points are stored in a list
user later by correction modules to get where to apply corrections
:return:

\end{fulllineitems}

\index{get\_multiple\_points() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.get_multiple_points}\pysiglinewithargsret{\bfcode{get\_multiple\_points}}{}{}
each tab as its own vector where input data points are stored in a list
user later by correction modules to get where to apply corrections
:return:

\end{fulllineitems}

\index{discard\_single\_point() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.discard_single_point}\pysiglinewithargsret{\bfcode{discard\_single\_point}}{}{}
after a single correction is applied
this function allows the user to undo it

before it is permanently applied
:return:

\end{fulllineitems}

\index{discard\_neutralise\_corrections() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.discard_neutralise_corrections}\pysiglinewithargsret{\bfcode{discard\_neutralise\_corrections}}{}{}
after correction are neutralised
this function allows the user to undo it

before it is permanently applied
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{discard\_multiple\_points() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.discard_multiple_points}\pysiglinewithargsret{\bfcode{discard\_multiple\_points}}{}{}
after multiple corrections are applied
this function allows the user to undo it

before it are permanently applied
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{which\_tab() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.which_tab}\pysiglinewithargsret{\bfcode{which\_tab}}{}{}
function used to detect which tab is currently active and set ax and widget
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
ax and widget name of current tab

\end{description}\end{quote}

\end{fulllineitems}

\index{show\_kb() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.show_kb}\pysiglinewithargsret{\bfcode{show\_kb}}{}{}
function that shows or hide the widget used to select corrections
so far max/min correction are +/- 5 fringes
:return:

\end{fulllineitems}

\index{handle\_exit\_button() (Cormat\_main.CORMAT\_GUI method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_exit_button}\pysiglinewithargsret{\bfcode{handle\_exit\_button}}{}{}
Exit the application

\end{fulllineitems}

\index{handle\_yes\_exit() (Cormat\_main.CORMAT\_GUI static method)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.CORMAT_GUI.handle_yes_exit}\pysiglinewithargsret{\strong{static }\bfcode{handle\_yes\_exit}}{}{}
close application
::todo: check why using this function doens't allow to use profiling (what exit values does it need?)

\end{fulllineitems}


\end{fulllineitems}

\index{main() (in module Cormat\_main)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.main}\pysiglinewithargsret{\code{Cormat\_main.}\bfcode{main}}{}{}
Main function

the only input to the GUI is the debug

by default is set to INFO

\end{fulllineitems}

\index{bin\_() (in module Cormat\_main)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.bin_}\pysiglinewithargsret{\code{Cormat\_main.}\bfcode{bin\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}

\index{hex\_() (in module Cormat\_main)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.hex_}\pysiglinewithargsret{\code{Cormat\_main.}\bfcode{hex\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}

\index{oct\_() (in module Cormat\_main)}

\begin{fulllineitems}
\phantomsection\label{Cormat_main:Cormat_main.oct_}\pysiglinewithargsret{\code{Cormat\_main.}\bfcode{oct\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}



\chapter{Modules}
\label{modules:modules}\label{modules::doc}

\section{find\_disruption module}
\label{find_disruption:module-find_disruption}\label{find_disruption:find-disruption-module}\label{find_disruption::doc}\index{find\_disruption (module)}
Code to read in disruption JPF and check
for a disruption. Set the time-dependent status flags for the KG1
signals to 3 around the disruption.

Returns a boolean to say if there was a disruption or not.
Also returns two times: {[}disruption time - disruption window, disruption time + disruption window{]}

The rest of the KG1 code will not attempt to make any corrections within this time window.
\index{find\_disruption() (in module find\_disruption)}

\begin{fulllineitems}
\phantomsection\label{find_disruption:find_disruption.find_disruption}\pysiglinewithargsret{\code{find\_disruption.}\bfcode{find\_disruption}}{\emph{shot\_no}, \emph{constants}, \emph{kg1\_signals=None}}{}
Find the disruption time from the JPF disruption signal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{constants}} -- Instance of Kg1Consts, contains JPF node names and size of time window around disruption to exclude.

\item {} 
\textbf{\texttt{kg1\_signals}} -- Instance of Kg1Data

\end{itemize}

\item[{Returns}] \leavevmode
Boolean for whether there was a disruption, {[}start disruption window, end disruption window{]}

\end{description}\end{quote}

\end{fulllineitems}



\section{consts module}
\label{consts:consts-module}\label{consts:module-consts}\label{consts::doc}\index{consts (module)}
Class for reading in and storing kg1 constants,
signal names etc.
\index{Consts (class in consts)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts}\pysiglinewithargsret{\strong{class }\code{consts.}\bfcode{Consts}}{\emph{config\_name}, \emph{code\_version}}{}
Bases: \code{object}
\index{DFR\_DCN (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.DFR_DCN}\pysigline{\bfcode{DFR\_DCN}\strong{ = 1.143e+19}}
\end{fulllineitems}

\index{DFR\_MET (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.DFR_MET}\pysigline{\bfcode{DFR\_MET}\strong{ = 1.876136e+19}}
\end{fulllineitems}

\index{MAT11 (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.MAT11}\pysigline{\bfcode{MAT11}\strong{ = 9.088193e+18}}
\end{fulllineitems}

\index{MAT12 (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.MAT12}\pysigline{\bfcode{MAT12}\strong{ = -5.536807e+18}}
\end{fulllineitems}

\index{MAT21 (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.MAT21}\pysigline{\bfcode{MAT21}\strong{ = 5.754791e-05}}
\end{fulllineitems}

\index{MAT22 (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.MAT22}\pysigline{\bfcode{MAT22}\strong{ = -9.445996e-05}}
\end{fulllineitems}

\index{CORR\_NE (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.CORR_NE}\pysigline{\bfcode{CORR\_NE}\strong{ = array({[}-5.60e+18,  9.10e+18,  3.50e+18,  1.46e+19,  2.58e+19,  2.02e+19,        -2.10e+18, -7.60e+18,  3.49e+19,  2.37e+19,  1.26e+19,  1.50e+18,         3.84e+19,  3.28e+19,  2.17e+19,  1.61e+19{]})}}
\end{fulllineitems}

\index{CORR\_VIB (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.CORR_VIB}\pysigline{\bfcode{CORR\_VIB}\strong{ = array({[}-9.513e-05,  5.770e-05, -3.740e-05,  1.528e-04,  3.438e-04,         2.479e-04, -1.326e-04, -2.277e-04,  4.007e-04,  2.105e-04,         2.020e-05, -1.700e-04,  3.633e-04,  2.682e-04,  7.790e-05,        -1.720e-05{]})}}
\end{fulllineitems}

\index{FJ\_DCN (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.FJ_DCN}\pysigline{\bfcode{FJ\_DCN}\strong{ = array({[}0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3{]})}}
\end{fulllineitems}

\index{FJ\_MET (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.FJ_MET}\pysigline{\bfcode{FJ\_MET}\strong{ = array({[} 1,  0,  1, -1, -3, -2,  2,  3, -3, -1,  1,  3, -2, -1,  1,  2{]})}}
\end{fulllineitems}

\index{JXB\_FAC (consts.Consts attribute)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.JXB_FAC}\pysigline{\bfcode{JXB\_FAC}\strong{ = {[}-1.6e-05, -3e-05, -4.5e-05, -3e-05{]}}}
\end{fulllineitems}

\index{get\_phase\_node\_dcn() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_phase_node_dcn}\pysiglinewithargsret{\bfcode{get\_phase\_node\_dcn}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the DCN phase, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1r, kg1c\_ldraw, kg1c\_ld, kg1c\_ldcor or kg1v

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_phase\_node\_met() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_phase_node_met}\pysiglinewithargsret{\bfcode{get\_phase\_node\_met}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the MET phase, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1r, kg1c\_ldraw, kg1c\_ld, kg1c\_ldcor or kg1v

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_amp\_node\_dcn() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_amp_node_dcn}\pysiglinewithargsret{\bfcode{get\_amp\_node\_dcn}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the DCN amplitude signal, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1r, kg1c\_ldraw, kg1c\_ld, kg1c\_ldcor or kg1v

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_amp\_node\_met() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_amp_node_met}\pysiglinewithargsret{\bfcode{get\_amp\_node\_met}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the MET amplitude signal, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1r, kg1c\_ldraw, kg1c\_ld, kg1c\_ldcor or kg1v

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sts\_node\_dcn() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_sts_node_dcn}\pysiglinewithargsret{\bfcode{get\_sts\_node\_dcn}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the DCN KG1C STS signal, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1c\_ldraw, kg1c\_ld or kg1c\_ldcor

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sts\_node\_met() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_sts_node_met}\pysiglinewithargsret{\bfcode{get\_sts\_node\_met}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the MET KG1C STS signal, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1c\_ldraw, kg1c\_ld or kg1c\_ldcor

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fj\_node\_dcn() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_fj_node_dcn}\pysiglinewithargsret{\bfcode{get\_fj\_node\_dcn}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the DCN KG1C FJ signal, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1c\_ldraw, kg1c\_ld or kg1c\_ldcor

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fj\_node\_met() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.get_fj_node_met}\pysiglinewithargsret{\bfcode{get\_fj\_node\_met}}{\emph{chan}, \emph{sig\_type}}{}
Return the appropriate JPF node name for the MET KG1C FJ signal, given the signal type \& channel number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chan}} -- Channel number

\item {} 
\textbf{\texttt{sig\_type}} -- Signal type: kg1c\_ldraw, kg1c\_ld or kg1c\_ldcor

\end{itemize}

\item[{Returns}] \leavevmode
JPF node name

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_time\_windows() (consts.Consts method)}

\begin{fulllineitems}
\phantomsection\label{consts:consts.Consts.set_time_windows}\pysiglinewithargsret{\bfcode{set\_time\_windows}}{\emph{ip\_times}, \emph{nbi\_times}, \emph{flattop\_times}}{}
Set time windows
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ip\_times}} -- {[}start ip, end ip{]}

\item {} 
\textbf{\texttt{nbi\_times}} -- {[}start\_nbi, end\_nbi{]}

\item {} 
\textbf{\texttt{flattop\_times}} -- {[}start\_flat, end\_flat{]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{library module}
\label{library:module-library}\label{library:library-module}\label{library::doc}\index{library (module)}\index{test\_logger() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.test_logger}\pysiglinewithargsret{\code{library.}\bfcode{test\_logger}}{}{}
\end{fulllineitems}

\index{reconnect() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.reconnect}\pysiglinewithargsret{\code{library.}\bfcode{reconnect}}{\emph{signal}, \emph{newhandler=None}, \emph{oldhandler=None}}{}
\end{fulllineitems}

\index{is\_empty() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.is_empty}\pysiglinewithargsret{\code{library.}\bfcode{is\_empty}}{\emph{any\_structure}}{}
\end{fulllineitems}

\index{are\_eq() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.are_eq}\pysiglinewithargsret{\code{library.}\bfcode{are\_eq}}{\emph{a}, \emph{b}}{}
\end{fulllineitems}

\index{autoscale\_data() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.autoscale_data}\pysiglinewithargsret{\code{library.}\bfcode{autoscale\_data}}{\emph{ax}, \emph{data}}{}
\end{fulllineitems}

\index{find\_nearest() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.find_nearest}\pysiglinewithargsret{\code{library.}\bfcode{find\_nearest}}{\emph{array}, \emph{value}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- 

\item {} 
\textbf{\texttt{value}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
returns value and index of the closest element in the array to the value

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_in\_list\_array() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.find_in_list_array}\pysiglinewithargsret{\code{library.}\bfcode{find\_in\_list\_array}}{\emph{array}, \emph{value}}{}
\end{fulllineitems}

\index{find\_within\_range() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.find_within_range}\pysiglinewithargsret{\code{library.}\bfcode{find\_within\_range}}{\emph{array}, \emph{minvalue}, \emph{maxvalue}}{}
\end{fulllineitems}

\index{norm() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.norm}\pysiglinewithargsret{\code{library.}\bfcode{norm}}{\emph{data}}{}
\end{fulllineitems}

\index{normalise() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.normalise}\pysiglinewithargsret{\code{library.}\bfcode{normalise}}{\emph{signal}, \emph{kg1\_signal}, \emph{dis\_time}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{signal}} -- second trace

\item {} 
\textbf{\texttt{kg1\_signal}} -- KG1 signal

\item {} 
\textbf{\texttt{dis\_time}} -- disruption time

\end{itemize}

\item[{Returns}] \leavevmode
Use ratio of maximum of signal - kg1 as the normalisation factor. Exclude region around the disruption.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_seq() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.get_seq}\pysiglinewithargsret{\code{library.}\bfcode{get\_seq}}{\emph{shot\_no}, \emph{dda}, \emph{read\_uid='JETPPF'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- pulse number

\item {} 
\textbf{\texttt{dda}} -- 

\item {} 
\textbf{\texttt{read\_uid}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
get sequence of a ppf

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_min\_max\_seq() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.get_min_max_seq}\pysiglinewithargsret{\code{library.}\bfcode{get\_min\_max\_seq}}{\emph{shot\_no}, \emph{dda='KG1V'}, \emph{read\_uid='JETPPF'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- 

\item {} 
\textbf{\texttt{dda}} -- 

\item {} 
\textbf{\texttt{read\_uid}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
return min and max sequence for given pulse, dda and readuid

\end{description}\end{quote}

min is the unvalidated sequence
max is the last validated sequence

\end{fulllineitems}

\index{check\_SF() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.check_SF}\pysiglinewithargsret{\code{library.}\bfcode{check\_SF}}{\emph{read\_uid}, \emph{pulse}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{read\_uid}} -- 

\item {} 
\textbf{\texttt{pulse}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
list of Status Flags

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_history() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.extract_history}\pysiglinewithargsret{\code{library.}\bfcode{extract\_history}}{\emph{filename}, \emph{outputfile}}{}
running this script will create a csv file containing a list of all the
ppf that have been created with Cormat\_py code

the script reads a log file (generally in /u/user/work/Python/Cormat\_py)

and writes an output file in the current working directory

the file is formatted in this way
shot: \{\} user: \{\} date: \{\} seq: \{\} by: \{\}
user is the write user id
by is the userid of the user of the code
the output is appended and there is a check on duplicates

if the user have never run KG1\_py code the file will be empty
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- name of KG1L (or KG1H) diary to be read

\item {} 
\textbf{\texttt{outputfile}} -- name of the output file

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{check\_string\_in\_file() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.check_string_in_file}\pysiglinewithargsret{\code{library.}\bfcode{check\_string\_in\_file}}{\emph{filename}, \emph{string}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- 

\item {} 
\textbf{\texttt{string}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
checks if the string is in that file

\end{description}\end{quote}

\end{fulllineitems}

\index{equalsFile() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.equalsFile}\pysiglinewithargsret{\code{library.}\bfcode{equalsFile}}{\emph{firstFile}, \emph{secondFile}, \emph{blocksize=65536}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{firstFile}} -- 

\item {} 
\textbf{\texttt{secondFile}} -- 

\item {} 
\textbf{\texttt{blocksize}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
returns True if files are the same,i.e. secondFile has same checksum as first

\end{description}\end{quote}

\end{fulllineitems}

\index{pyqt\_set\_trace() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.pyqt_set_trace}\pysiglinewithargsret{\code{library.}\bfcode{pyqt\_set\_trace}}{}{}
Set a tracepoint in the Python debugger that works with Qt

\end{fulllineitems}

\index{copy\_changed\_kg1\_to\_save() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.copy_changed_kg1_to_save}\pysiglinewithargsret{\code{library.}\bfcode{copy\_changed\_kg1\_to\_save}}{\emph{src}, \emph{dst}, \emph{filename}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- 

\item {} 
\textbf{\texttt{dst}} -- 

\item {} 
\textbf{\texttt{filename}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
copies file from src folder to dst

\end{description}\end{quote}

\end{fulllineitems}

\index{delete\_files\_in\_folder() (in module library)}

\begin{fulllineitems}
\phantomsection\label{library:library.delete_files_in_folder}\pysiglinewithargsret{\code{library.}\bfcode{delete\_files\_in\_folder}}{\emph{folder}}{}
\end{fulllineitems}



\section{ppf\_write}
\label{ppf_write:module-ppf_write}\label{ppf_write:ppf-write}\label{ppf_write::doc}\index{ppf\_write (module)}
Wrapper for opening, writing \& closing a PPF.
\begin{description}
\item[{TO DO: Implement Time-Dependent Status Flags. I don't seem to be able to set tdsf's AND specify an itref in order}] \leavevmode
to use a previous dtype's time-vector.

\end{description}

added
output file with log
shot,user,date,seq
\index{check\_uid() (in module ppf\_write)}

\begin{fulllineitems}
\phantomsection\label{ppf_write:ppf_write.check_uid}\pysiglinewithargsret{\code{ppf\_write.}\bfcode{check\_uid}}{\emph{shot\_no}, \emph{write\_uid}}{}
Open PPF to check if UID is valid, then abort
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{write\_uid}} -- write\_uid

\end{itemize}

\item[{Returns}] \leavevmode
1 if UID is invalid, 0 otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_ppf() (in module ppf\_write)}

\begin{fulllineitems}
\phantomsection\label{ppf_write:ppf_write.open_ppf}\pysiglinewithargsret{\code{ppf\_write.}\bfcode{open\_ppf}}{\emph{shot\_no}, \emph{write\_uid}, \emph{comment='CORRECTED KG1 DATA FROM KG1C AND KG1R   `}}{}
Open PPF for writing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{write\_uid}} -- write UID

\end{itemize}

\item[{Returns}] \leavevmode
error code from PPF system. It will be 0 if there is no error.

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_ppf() (in module ppf\_write)}

\begin{fulllineitems}
\phantomsection\label{ppf_write:ppf_write.write_ppf}\pysiglinewithargsret{\code{ppf\_write.}\bfcode{write\_ppf}}{\emph{shot\_no}, \emph{dda}, \emph{dtype}, \emph{data}, \emph{time=None}, \emph{comment=None}, \emph{unitd=None}, \emph{unitt=None}, \emph{itref=-1}, \emph{nt=None}, \emph{global\_status=None}, \emph{status=None}}{}
Write PPF DDA/DTYPE
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{dda}} -- DDA

\item {} 
\textbf{\texttt{dtype}} -- DTYPE

\item {} 
\textbf{\texttt{data}} -- numpy array of data

\item {} 
\textbf{\texttt{time}} -- numpy array of time

\item {} 
\textbf{\texttt{comment}} -- comment

\item {} 
\textbf{\texttt{unitd}} -- units for data

\item {} 
\textbf{\texttt{unitt}} -- units for time

\item {} 
\textbf{\texttt{itref}} -- reference for timebase

\item {} 
\textbf{\texttt{nt}} -- size of the time vector

\item {} 
\textbf{\texttt{global\_status}} -- status for the DTYPE

\item {} 
\textbf{\texttt{status}} -- time-dependent status

\end{itemize}

\item[{Returns}] \leavevmode
error code (0 if everything is OK), itref for timebase written

\end{description}\end{quote}

\end{fulllineitems}

\index{close\_ppf() (in module ppf\_write)}

\begin{fulllineitems}
\phantomsection\label{ppf_write:ppf_write.close_ppf}\pysiglinewithargsret{\code{ppf\_write.}\bfcode{close\_ppf}}{\emph{shot\_no}, \emph{write\_uid}, \emph{version}}{}
Close PPF
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- shot number

\item[{Returns}] \leavevmode
error code, 0 if everything is OK

\end{description}\end{quote}

\end{fulllineitems}



\section{status\_flag module}
\label{status_flag:status-flag-module}\label{status_flag::doc}\phantomsection\label{status_flag:module-status_flag}\index{status\_flag (module)}
Simple program to access status flags
contains a main that creates a database for a given pulse list
\index{find\_disruption() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.find_disruption}\pysiglinewithargsret{\code{status\_flag.}\bfcode{find\_disruption}}{\emph{pulse}}{}
given a pulse return if it has disrupted (True) or not (False)     returns n/a if there is no information about disruptions
:param pulse:
:return: boolean

\end{fulllineitems}

\index{initread() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.initread}\pysiglinewithargsret{\code{status\_flag.}\bfcode{initread}}{}{}
initialize ppf
:return:

\end{fulllineitems}

\index{GetSF() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.GetSF}\pysiglinewithargsret{\code{status\_flag.}\bfcode{GetSF}}{\emph{pulse}, \emph{dda}, \emph{dtype}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pulse}} -- 

\item {} 
\textbf{\texttt{dda}} -- string e.g. `kg1v'

\item {} 
\textbf{\texttt{dtype}} -- string e.g. `lid3'

\end{itemize}

\item[{Returns}] \leavevmode
SF := status flag

\end{description}\end{quote}

\end{fulllineitems}

\index{Getnonvalidatedpulses() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.Getnonvalidatedpulses}\pysiglinewithargsret{\code{status\_flag.}\bfcode{Getnonvalidatedpulses}}{\emph{pulselist}, \emph{dtypelist}, \emph{SF\_validated}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pulselist}} -- list of pulses

\item {} 
\textbf{\texttt{dtypelist}} -- string e.g. `lid1','lid2',...

\item {} 
\textbf{\texttt{SF\_validated}} -- integer rapresenting SF for validated shots

\end{itemize}

\item[{Returns}] \leavevmode
array of integer with pulse numbers,status flag list

\end{description}\end{quote}

\end{fulllineitems}

\index{GETfringejumps() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.GETfringejumps}\pysiglinewithargsret{\code{status\_flag.}\bfcode{GETfringejumps}}{\emph{pulse}, \emph{FJC\_dtypelist}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pulse}} -- pulse number

\item {} 
\textbf{\texttt{FJC\_dtypelist}} -- string e.g. `FC1','FC2',...

\end{itemize}

\item[{Returns}] \leavevmode
array of integer, rapresenting fringe jumps corrections

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.main}\pysiglinewithargsret{\code{status\_flag.}\bfcode{main}}{\emph{pulse1}, \emph{pulse2}, \emph{FJthres}, \emph{outputfilename}}{}
:param pulse1:intial pulse
:param pulse2: final pulse
:param FJthres: threshold to be used to check number of fringe jumps in pulse
:param outputfilename: output database name
:return: database containing all pulses inside the given interval whose median of fringe jumps exceed the given threshold and marks if there was a disruption or not

\end{fulllineitems}

\index{printdict() (in module status\_flag)}

\begin{fulllineitems}
\phantomsection\label{status_flag:status_flag.printdict}\pysiglinewithargsret{\code{status\_flag.}\bfcode{printdict}}{\emph{goodpulses\_sorted}}{}
\end{fulllineitems}



\section{wv\_denoise module}
\label{wv_denoise:wv-denoise-module}\label{wv_denoise:module-wv_denoise}\label{wv_denoise::doc}\index{wv\_denoise (module)}
Module containg wv\_densoise, a function to filter a signal using wavelet filtering.
Determination of threshold from ncoeff and percent is
done as in the idl function wv\_denoise.pro.
\index{wv\_denoise() (in module wv\_denoise)}

\begin{fulllineitems}
\phantomsection\label{wv_denoise:wv_denoise.wv_denoise}\pysiglinewithargsret{\code{wv\_denoise.}\bfcode{wv\_denoise}}{\emph{signal}, \emph{family=None}, \emph{nlevels=None}, \emph{ncoeff=None}, \emph{percent=None}}{}
Function to filter a signal using wavelet filtering.
Determination of threshold from ncoeff and percent is
done as in the idl function wv\_denoise.pro.
For more details on wavelet options see PyWavelet docs.
If neither coeff or percent are specified then no filtering is
done.

TO DO:
\begin{itemize}
\item {} 
Implement soft threshold

\item {} 
Thresholding using variance or something?

\item {} 
Think and check: divisible by 2 thing

\item {} 
2D filter?

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{signal}} -- signal to be filtered.

\item {} 
\textbf{\texttt{family}} -- Wavelet family and order to use (default is `db1')

\item {} 
\textbf{\texttt{nlevels}} -- Number of levels of DWT to perform. If none is given then
decomposition upto dwt\_max\_level is done, which
is the maximum useful level as computed by pyWavelets.

\item {} 
\textbf{\texttt{ncoeff}} -- The number of coefficients to retain when filtering.
If specified then percent is ignored.

\item {} 
\textbf{\texttt{percent}} -- The percentage of coefficients to retain when filtering.
If specified then coeff is ignored.

\end{itemize}

\item[{Returns}] \leavevmode
the filtered signal

\end{description}\end{quote}

\end{fulllineitems}



\section{wv\_get\_background module}
\label{wv_get_background:wv-get-background-module}\label{wv_get_background:module-wv_get_background}\label{wv_get_background::doc}\index{wv\_get\_background (module)}
Module for determining the background in a signal.
Approximate implementation of the method described in Galloway et al. (2009),
An iterative algorithm for background removal in spectroscopy by wavelet transforms, ),
which finds the background using an iterative wavelet filtering method .Applied Spectroscopy, 63, 1370

Depends on wv\_denoise

It's a bit slow...
\index{recursive\_wv() (in module wv\_get\_background)}

\begin{fulllineitems}
\phantomsection\label{wv_get_background:wv_get_background.recursive_wv}\pysiglinewithargsret{\code{wv\_get\_background.}\bfcode{recursive\_wv}}{\emph{data}, \emph{ind\_times}, \emph{currentiter=0}, \emph{niter=10}, \emph{nlevels=12}}{}
Recursively find background of the data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- data

\item {} 
\textbf{\texttt{ind\_times}} -- time indices of background regions

\item {} 
\textbf{\texttt{currentiter}} -- current iteration number

\item {} 
\textbf{\texttt{niter}} -- total number of iterations

\item {} 
\textbf{\texttt{nlevels}} -- number of levels for the wavelet filtering

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{wv\_get\_background() (in module wv\_get\_background)}

\begin{fulllineitems}
\phantomsection\label{wv_get_background:wv_get_background.wv_get_background}\pysiglinewithargsret{\code{wv\_get\_background.}\bfcode{wv\_get\_background}}{\emph{time}, \emph{data}, \emph{start\_time}, \emph{end\_time}, \emph{nlevels=12}}{}
Use wavelet filtering to determine the background for a data set
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{time}} -- array of time values

\item {} 
\textbf{\texttt{data}} -- array of data values

\item {} 
\textbf{\texttt{start\_time}} -- time before which signal can be considered to be background

\item {} 
\textbf{\texttt{end\_time}} -- time after which signal can be considered to be background

\item {} 
\textbf{\texttt{nlevels}} -- number of levels to use for the wavelet filtering

\end{itemize}

\item[{Returns}] \leavevmode
background

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Classes}
\label{classes:classes}\label{classes::doc}

\section{SignalBase}
\label{signal_base:module-signal_base}\label{signal_base:signalbase}\label{signal_base::doc}\index{signal\_base (module)}
Class for reading and storing a signal from the PPF or JPF system, 
with functionality for filtering, resampling, and calculating the 
differences between adjacent time points.
\index{decimate\_ZP() (in module signal\_base)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.decimate_ZP}\pysiglinewithargsret{\code{signal\_base.}\bfcode{decimate\_ZP}}{\emph{x}, \emph{q}, \emph{n=None}, \emph{ftype='iir'}, \emph{axis=-1}, \emph{zero\_phase=False}}{}
Downsample the signal by using a filter.
By default, an order 8 Chebyshev type I filter is used.  A 30 point FIR
filter with hamming window is used if \titleref{ftype} is `fir'.
Parameters
----------
x : ndarray
\begin{quote}

The signal to be downsampled, as an N-dimensional array.
\end{quote}
\begin{description}
\item[{q}] \leavevmode{[}int{]}
The downsampling factor.

\item[{n}] \leavevmode{[}int, optional{]}
The order of the filter (1 less than the length for `fir').

\item[{ftype}] \leavevmode{[}str \{`iir', `fir'\}, optional{]}
The type of the lowpass filter.

\item[{axis}] \leavevmode{[}int, optional{]}
The axis along which to decimate.

\item[{zero\_phase}] \leavevmode{[}bool{]}
Prevent phase shift by filtering with \code{filtfilt} instead of \code{lfilter}.

\end{description}
\begin{description}
\item[{y}] \leavevmode{[}ndarray{]}
The down-sampled signal.

\end{description}

resample

The \code{zero\_phase} keyword was added in 0.17.0.
The possibility to use instances of \code{lti} as \code{ftype} was added in 0.17.0.

\end{fulllineitems}

\index{gcd() (in module signal\_base)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.gcd}\pysiglinewithargsret{\code{signal\_base.}\bfcode{gcd}}{\emph{a}, \emph{b}}{}
Compute the greatest common divisor of a and b

\end{fulllineitems}

\index{lcm() (in module signal\_base)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.lcm}\pysiglinewithargsret{\code{signal\_base.}\bfcode{lcm}}{\emph{a}, \emph{b}}{}
Compute the lowest common multiple of a and b

\end{fulllineitems}

\index{SignalBase (class in signal\_base)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase}\pysiglinewithargsret{\strong{class }\code{signal\_base.}\bfcode{SignalBase}}{\emph{constants}}{}
Bases: \code{object}
\index{read\_data\_ppf() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.read_data_ppf}\pysiglinewithargsret{\bfcode{read\_data\_ppf}}{\emph{dda}, \emph{dtype}, \emph{shot\_no}, \emph{read\_bad=False}, \emph{read\_uid='JETPPF'}, \emph{seq=0}}{}
Read in and store PPF data
:param dda: DDA
:param dtype: DTYPE
:param shot\_no: shot number
:param read\_bad: If set to true, data is read in for all sequence numbers (even status == 4)
:param read\_uid: UID to use to read PPF data
:param seq: sequence number to read in

\end{fulllineitems}

\index{read\_data\_jpf() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.read_data_jpf}\pysiglinewithargsret{\bfcode{read\_data\_jpf}}{\emph{signal\_name}, \emph{shot\_no}, \emph{use\_64bit=False}}{}
Read in and store JPF data
:param signal\_name: Node name for JPF
:param shot\_no: shot number
:param use\_64bit: If set to true the data is stored as 64 bit float

\end{fulllineitems}

\index{read\_data\_jpf\_1D() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.read_data_jpf_1D}\pysiglinewithargsret{\bfcode{read\_data\_jpf\_1D}}{\emph{signal\_name}, \emph{shot\_no}}{}
Read in JPF data with only one dimension
:param signal\_name: signal name
:param shot\_no: shot number

\end{fulllineitems}

\index{filter\_signal() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.filter_signal}\pysiglinewithargsret{\bfcode{filter\_signal}}{\emph{family}, \emph{ncoeff=None}, \emph{percent=None}, \emph{start\_time=0}, \emph{end\_time=0}}{}
Filter the signal using wavelet filtering
:param family: wavelet family to use for filtering
:param ncoeff: number of coefficients to retain in the filtering
:param percent: percentage of coefficients to retain in the filtering
:param start\_time: Time from which to start the filtering
:param end\_time: Time to finish the filtering
:return: numpy array containing the filtered data from start\_time - end\_time

\end{fulllineitems}

\index{get\_time\_inds() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.get_time_inds}\pysiglinewithargsret{\bfcode{get\_time\_inds}}{\emph{start\_time}, \emph{end\_time}}{}
Get the index of the times corresponding to start\_time and end\_time
:param start\_time: start time
:param end\_time: end time
:return: index of start\_time, index of end\_time

\end{fulllineitems}

\index{resample\_signal() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.resample_signal}\pysiglinewithargsret{\bfcode{resample\_signal}}{\emph{resample\_method}, \emph{new\_time}}{}
Resample the signal, to a different timebase,
by
-interpolation,
-zeropadding
:param resample\_method: method to use, only ``interp'' implemented atm.
:return: numpy array of resampled data

\end{fulllineitems}

\index{get\_differences() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.get_differences}\pysiglinewithargsret{\bfcode{get\_differences}}{\emph{npoints}}{}
Get the difference between the data npoints apart.
:param npoints: Number of points over which to calculate the difference
:return: numpy array of difference

\end{fulllineitems}

\index{get\_second\_differences() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.get_second_differences}\pysiglinewithargsret{\bfcode{get\_second\_differences}}{\emph{npoints}}{}
Get the second differential over npoints
:param npoints: Number of points over which to calculate the difference
:return: numpy array of second differential

\end{fulllineitems}

\index{delete\_points() (signal\_base.SignalBase method)}

\begin{fulllineitems}
\phantomsection\label{signal_base:signal_base.SignalBase.delete_points}\pysiglinewithargsret{\bfcode{delete\_points}}{\emph{ind\_points}}{}
Delete points with indices ind\_points
:param ind\_points: indices of points to delete

\end{fulllineitems}


\end{fulllineitems}



\section{Signalkg1}
\label{signal_kg1:signalkg1}\label{signal_kg1:module-signal_kg1}\label{signal_kg1::doc}\index{signal\_kg1 (module)}
Class for reading and storing KG1 signals.

Inherits from SignalBase (signal\_base.py).

Additional functionality for correcting fringe 
jumps and storing status flags
\index{SignalKg1 (class in signal\_kg1)}

\begin{fulllineitems}
\phantomsection\label{signal_kg1:signal_kg1.SignalKg1}\pysiglinewithargsret{\strong{class }\code{signal\_kg1.}\bfcode{SignalKg1}}{\emph{constants}, \emph{shot\_no}}{}
Bases: {\hyperref[signal_base:signal_base.SignalBase]{\crossref{\code{signal\_base.SignalBase}}}}
\index{uncorrect\_fj() (signal\_kg1.SignalKg1 method)}

\begin{fulllineitems}
\phantomsection\label{signal_kg1:signal_kg1.SignalKg1.uncorrect_fj}\pysiglinewithargsret{\bfcode{uncorrect\_fj}}{\emph{corr}, \emph{index}, \emph{fringe\_vib=None}}{}
Uncorrect a fringe jump by corr, from the time corresponding to index onwards.
Not used ATM. Will need more testing if we want to use it... Suspect isclose is wrong.
07mar2019
used this function instead of is close as there is an issue with types and the value we are looking for
sometimes are not found
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{corr}} -- Correction to add to the data

\item {} 
\textbf{\texttt{index}} -- Index from which to make the correction

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_fj() (signal\_kg1.SignalKg1 method)}

\begin{fulllineitems}
\phantomsection\label{signal_kg1:signal_kg1.SignalKg1.correct_fj}\pysiglinewithargsret{\bfcode{correct\_fj}}{\emph{corr}, \emph{time=None}, \emph{index=None}, \emph{store=True}, \emph{corr\_dcn=None}, \emph{corr\_met=None}, \emph{lid=None}}{}
Shifts all data from time onwards, or index onwards,
down by corr. Either time or index must be specified
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{corr}} -- The correction to be subtracted

\item {} 
\textbf{\texttt{time}} -- The time from which to make the correction (if this is specified index is ignored)

\item {} 
\textbf{\texttt{index}} -- The index from which to make the correction

\item {} 
\textbf{\texttt{store}} -- To record the correction set to True

\item {} 
\textbf{\texttt{corr\_dcn}} -- Only for use with lateral channels. Stores the correction,
in terms of the number of FJ in DCN laser (as opposed to in the combined density)

\item {} 
\textbf{\texttt{corr\_met}} -- Only for use with lateral channels. Stores the correction,
in terms of the number of FJ in the MET laser (as opposed to the correction in the vibration)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{SignalAmp}
\label{signal_amp:signalamp}\label{signal_amp:module-signal_amp}\label{signal_amp::doc}\index{signal\_amp (module)}
Class for reading and storing KG1 amplitude signals.

Inherits from SignalBase (signal\_base.py).

Additional functionality for finding bad points,
and checking if the amplitude is valid in general
\index{SignalAmp (class in signal\_amp)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp}\pysiglinewithargsret{\strong{class }\code{signal\_amp.}\bfcode{SignalAmp}}{\emph{constants}}{}
Bases: {\hyperref[signal_base:signal_base.SignalBase]{\crossref{\code{signal\_base.SignalBase}}}}
\index{KG1C\_START\_AMP\_BAD (signal\_amp.SignalAmp attribute)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.KG1C_START_AMP_BAD}\pysigline{\bfcode{KG1C\_START\_AMP\_BAD}\strong{ = 0.2}}
\end{fulllineitems}

\index{KG1R\_START\_AMP\_BAD (signal\_amp.SignalAmp attribute)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.KG1R_START_AMP_BAD}\pysigline{\bfcode{KG1R\_START\_AMP\_BAD}\strong{ = 3500}}
\end{fulllineitems}

\index{KG1V\_START\_AMP\_BAD (signal\_amp.SignalAmp attribute)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.KG1V_START_AMP_BAD}\pysigline{\bfcode{KG1V\_START\_AMP\_BAD}\strong{ = 0.5}}
\end{fulllineitems}

\index{KG1R\_TIME\_AMP\_CHECK (signal\_amp.SignalAmp attribute)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.KG1R_TIME_AMP_CHECK}\pysigline{\bfcode{KG1R\_TIME\_AMP\_CHECK}\strong{ = 38.5}}
\end{fulllineitems}

\index{KG1V\_TIME\_AMP\_CHECK (signal\_amp.SignalAmp attribute)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.KG1V_TIME_AMP_CHECK}\pysigline{\bfcode{KG1V\_TIME\_AMP\_CHECK}\strong{ = 32.0}}
\end{fulllineitems}

\index{read\_data\_ppf() (signal\_amp.SignalAmp method)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.read_data_ppf}\pysiglinewithargsret{\bfcode{read\_data\_ppf}}{\emph{dda}, \emph{dtype}, \emph{shot\_no}, \emph{signal\_type}, \emph{dcn\_or\_met}}{}
Overide read\_data\_ppf method, to include additional
argument to set the signal type \& dcn\_or\_met.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{dda}} -- DDA

\item {} 
\textbf{\texttt{dtype}} -- DTYPE

\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{signal\_type}} -- String to indicate if this is KG1R, KG1C or KG1V

\item {} 
\textbf{\texttt{dcn\_or\_met}} -- ``dcn'' or ``met'' depending on whether signal is from DCN or MET laser

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_data\_jpf() (signal\_amp.SignalAmp method)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.read_data_jpf}\pysiglinewithargsret{\bfcode{read\_data\_jpf}}{\emph{signal\_name}, \emph{shot\_no}, \emph{signal\_type}, \emph{dcn\_or\_met}}{}
Overide read\_data\_jpf method, to include additional argument to set the signal type
and check the amplitude of the signal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{signal\_name}} -- JPF signal name

\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{signal\_type}} -- Identifies whether data is KG1C or KG1R or KG1V

\item {} 
\textbf{\texttt{dcn\_or\_met}} -- ``dcn'' or ``met'', ie. signal is from DCN or MET laser

\end{itemize}

\item[{Returns}] \leavevmode
0: Amplitude was read in and is OK,
9: Error reading the JPF signal,
10: The amplitude is bad

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_bad\_points() (signal\_amp.SignalAmp method)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp.find_bad_points}\pysiglinewithargsret{\bfcode{find\_bad\_points}}{}{}
Find points with a bad amplitude.
\begin{itemize}
\item {} 
For KG1C, CPRB should be within a valid range

\item {} 
For KG1R \& KG1V the amplitude should be above a certain value

\end{itemize}

:return indices of bad points

\end{fulllineitems}

\index{\_check\_amp\_average() (signal\_amp.SignalAmp method)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp._check_amp_average}\pysiglinewithargsret{\bfcode{\_check\_amp\_average}}{\emph{time}, \emph{threshold}}{}
Check the average amplitude at the start of the pulse is high enough.
For use with KG1R or KG1V
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
good\_amp : True if the amplitude is good, false otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{\_check\_amp\_kg1c() (signal\_amp.SignalAmp method)}

\begin{fulllineitems}
\phantomsection\label{signal_amp:signal_amp.SignalAmp._check_amp_kg1c}\pysiglinewithargsret{\bfcode{\_check\_amp\_kg1c}}{}{}
Check the CPRB signal (the KG1C frequency, which acts as the amplitude here).
The CPRB signal at the start of the pulse should be within 80\% of cprb\_mid.
It should also not fall below this value by more than cprb\_range too many times
in the whole pulse.
cprb\_mid and cprb\_range are different for DCN and MET lasers.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
good\_amp : True if the amplitude is good, false otherwise

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Kg1PPFData}
\label{kg1_ppf_data:kg1ppfdata}\label{kg1_ppf_data:module-kg1_ppf_data}\label{kg1_ppf_data::doc}\index{kg1\_ppf\_data (module)}
Class to read and store KG1 PPF data for one channel.
Reads in LIDX, FCX, MIRX, JXBX, TYPX
\index{Kg1PPFData (class in kg1\_ppf\_data)}

\begin{fulllineitems}
\phantomsection\label{kg1_ppf_data:kg1_ppf_data.Kg1PPFData}\pysiglinewithargsret{\strong{class }\code{kg1\_ppf\_data.}\bfcode{Kg1PPFData}}{\emph{constants}, \emph{pulse}}{}
Bases: {\hyperref[signal_base:signal_base.SignalBase]{\crossref{\code{signal\_base.SignalBase}}}}
\index{read\_data() (kg1\_ppf\_data.Kg1PPFData method)}

\begin{fulllineitems}
\phantomsection\label{kg1_ppf_data:kg1_ppf_data.Kg1PPFData.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{shot\_no}, \emph{read\_uid='JETPPF'}}{}
Read in PPF data for KG1V for a given channel
:param shot\_no: shot number
:param chan: channel
:param read\_uid: read UID
:return: True if data was read in successfully, False otherwise

\end{fulllineitems}

\index{set\_status() (kg1\_ppf\_data.Kg1PPFData method)}

\begin{fulllineitems}
\phantomsection\label{kg1_ppf_data:kg1_ppf_data.Kg1PPFData.set_status}\pysiglinewithargsret{\bfcode{set\_status}}{\emph{lid}, \emph{new\_status}, \emph{time=None}, \emph{index=None}}{}
Set time-dependent status flags for lid.
If neither time or index are given, set status flags for all time points
:param lid: LID number to set status for
:param new\_status: status to be set
:param time: time, or time range in which to set status.
:param index: index, or index range in which to set status.

\end{fulllineitems}

\index{get\_coord() (kg1\_ppf\_data.Kg1PPFData method)}

\begin{fulllineitems}
\phantomsection\label{kg1_ppf_data:kg1_ppf_data.Kg1PPFData.get_coord}\pysiglinewithargsret{\bfcode{get\_coord}}{\emph{shot\_no}}{}
Get vacuum vessel temperature \& extract spatial coordinates of KG4 chords from text file.
Function copied from A. Boboc's kg4r\_py code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- shot number

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_jpf\_point() (kg1\_ppf\_data.Kg1PPFData method)}

\begin{fulllineitems}
\phantomsection\label{kg1_ppf_data:kg1_ppf_data.Kg1PPFData.get_jpf_point}\pysiglinewithargsret{\bfcode{get\_jpf\_point}}{\emph{shot\_no}, \emph{node}}{}
Get a single value from the JPF
ie. Convert Nord data to real number
Function copied from A. Boboc's kg4r\_py code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{node}} -- JPF node

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{ElmsData}
\label{elms_data:elmsdata}\label{elms_data:module-elms_data}\label{elms_data::doc}\index{elms\_data (module)}
Class to read Be-II signals, and detect ELMs.

The disruption time can be specified, in which case only ELMs before this time will be detected

Method used for ELM detection:
\begin{itemize}
\item {} 
Only use the Be-II signal up until the disruption time, if there is a disruption.
This ensures that the filtering doesn't give us extra unwanted oscillations due
to the large signal at the time of the disruption.

\item {} 
Find the background using wavelet filtering (module wv\_get\_background).

\item {} 
Find ELMs by studying the first derivative of the Be-II signal. We are looking for a positive derivative, followed by a negative derivative. Different thresholds can be set for the positive \& negative derivative to account for the shape of the ELM signals (sharp rise, followed by shallower fall off).

\end{itemize}
\begin{description}
\item[{Future improvements:}] \leavevmode\begin{itemize}
\item {} 
Finding the background using wavelets is a bit slow: try a moving average

\item {} 
a variable threshold. Sometimes the threshold is too low/high, resulting in incorrectly detected ELMs or missing ELMs.

\end{itemize}

\end{description}
\index{ElmsData (class in elms\_data)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData}\pysiglinewithargsret{\strong{class }\code{elms\_data.}\bfcode{ElmsData}}{\emph{constants}, \emph{shot\_no}, \emph{dis\_time=0.0}}{}
Bases: \code{object}

Class to read Be-II signals, and detect ELMs.
\index{WV\_FAMILY (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.WV_FAMILY}\pysigline{\bfcode{WV\_FAMILY}\strong{ = `db15'}}
\end{fulllineitems}

\index{WV\_PERC (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.WV_PERC}\pysigline{\bfcode{WV\_PERC}\strong{ = 99.0}}
\end{fulllineitems}

\index{START\_TIME (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.START_TIME}\pysigline{\bfcode{START\_TIME}\strong{ = 40.0}}
\end{fulllineitems}

\index{END\_TIME (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.END_TIME}\pysigline{\bfcode{END\_TIME}\strong{ = 65.0}}
\end{fulllineitems}

\index{UP\_THRESH (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.UP_THRESH}\pysigline{\bfcode{UP\_THRESH}\strong{ = 0.5}}
\end{fulllineitems}

\index{DOWN\_THRESH (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.DOWN_THRESH}\pysigline{\bfcode{DOWN\_THRESH}\strong{ = -0.3}}
\end{fulllineitems}

\index{ELM\_WIDTH\_MAX (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.ELM_WIDTH_MAX}\pysigline{\bfcode{ELM\_WIDTH\_MAX}\strong{ = 0.1}}
\end{fulllineitems}

\index{BE\_START\_TIME (elms\_data.ElmsData attribute)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData.BE_START_TIME}\pysigline{\bfcode{BE\_START\_TIME}\strong{ = 35.0}}
\end{fulllineitems}

\index{\_find\_elms() (elms\_data.ElmsData method)}

\begin{fulllineitems}
\phantomsection\label{elms_data:elms_data.ElmsData._find_elms}\pysiglinewithargsret{\bfcode{\_find\_elms}}{\emph{shot\_no}, \emph{dis\_time}}{}
Read in ELMs signal and find elms
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\item {} 
\textbf{\texttt{dis\_time}} -- Disruption time. Set to zero for no disruption. ELMs will only be detected before this time.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{HRTSData}
\label{hrts_data:hrtsdata}\label{hrts_data:module-hrts_data}\label{hrts_data::doc}\index{hrts\_data (module)}
Class to read and store all hrts data
\index{HRTSData (class in hrts\_data)}

\begin{fulllineitems}
\phantomsection\label{hrts_data:hrts_data.HRTSData}\pysiglinewithargsret{\strong{class }\code{hrts\_data.}\bfcode{HRTSData}}{\emph{constants}}{}
Bases: \code{object}
\index{read\_data() (hrts\_data.HRTSData method)}

\begin{fulllineitems}
\phantomsection\label{hrts_data:hrts_data.HRTSData.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{shot\_no}, \emph{read\_uid='JETPPF'}}{}
Read in HRTX data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- shot number

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{LIDARData}
\label{lidar_data:module-lidar_data}\label{lidar_data:lidardata}\label{lidar_data::doc}\index{lidar\_data (module)}
Class to read and store all lidar data
\index{LIDARData (class in lidar\_data)}

\begin{fulllineitems}
\phantomsection\label{lidar_data:lidar_data.LIDARData}\pysiglinewithargsret{\strong{class }\code{lidar\_data.}\bfcode{LIDARData}}{\emph{constants}}{}
Bases: \code{object}
\index{read\_data() (lidar\_data.LIDARData method)}

\begin{fulllineitems}
\phantomsection\label{lidar_data:lidar_data.LIDARData.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{shot\_no}, \emph{read\_uid='JETPPF'}}{}
Read in lidar (LIDX)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- shot number

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Kg4Data}
\label{kg4_data:kg4data}\label{kg4_data:module-kg4_data}\label{kg4_data::doc}\index{kg4\_data (module)}
Class to read and store all kg4 data
\index{Kg4Data (class in kg4\_data)}

\begin{fulllineitems}
\phantomsection\label{kg4_data:kg4_data.Kg4Data}\pysiglinewithargsret{\strong{class }\code{kg4\_data.}\bfcode{Kg4Data}}{\emph{constants}}{}
Bases: \code{object}
\index{CIB (kg4\_data.Kg4Data attribute)}

\begin{fulllineitems}
\phantomsection\label{kg4_data:kg4_data.Kg4Data.CIB}\pysigline{\bfcode{CIB}\strong{ = 51.6}}
\end{fulllineitems}

\index{MIN\_FAR (kg4\_data.Kg4Data attribute)}

\begin{fulllineitems}
\phantomsection\label{kg4_data:kg4_data.Kg4Data.MIN_FAR}\pysigline{\bfcode{MIN\_FAR}\strong{ = 0.02}}
\end{fulllineitems}

\index{read\_data() (kg4\_data.Kg4Data method)}

\begin{fulllineitems}
\phantomsection\label{kg4_data:kg4_data.Kg4Data.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{mag}, \emph{shot\_no}}{}
Read in faraday angle \& ellipticity, and convert to densities
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mag}} -- Instance of MagData, with data read in already. Needed for conversion to density

\item {} 
\textbf{\texttt{shot\_no}} -- shot number

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{MagData}
\label{mag_data:magdata}\label{mag_data:module-mag_data}\label{mag_data::doc}\index{mag\_data (module)}
Class to read and store magnetics data
\index{MagData (class in mag\_data)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData}\pysiglinewithargsret{\strong{class }\code{mag\_data.}\bfcode{MagData}}{\emph{constants}}{}
Bases: \code{object}
\index{MIN\_IP (mag\_data.MagData attribute)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData.MIN_IP}\pysigline{\bfcode{MIN\_IP}\strong{ = 0.3}}
\end{fulllineitems}

\index{PER\_IP\_FLAT (mag\_data.MagData attribute)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData.PER_IP_FLAT}\pysigline{\bfcode{PER\_IP\_FLAT}\strong{ = 0.8}}
\end{fulllineitems}

\index{CBVAC (mag\_data.MagData attribute)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData.CBVAC}\pysigline{\bfcode{CBVAC}\strong{ = 5.1892e-05}}
\end{fulllineitems}

\index{MIN\_BVAC (mag\_data.MagData attribute)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData.MIN_BVAC}\pysigline{\bfcode{MIN\_BVAC}\strong{ = -1.5}}
\end{fulllineitems}

\index{read\_data() (mag\_data.MagData method)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{shot\_no}}{}
Read in magnetics data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- shot number

\item[{Returns}] \leavevmode
True if data was read successfully and there is ip
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}

\index{\_find\_ip\_times() (mag\_data.MagData method)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData._find_ip_times}\pysiglinewithargsret{\bfcode{\_find\_ip\_times}}{}{}
Find the start and end time of
the ip and the flat-top.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
False if there is no IP
True otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{\_find\_bvac\_times() (mag\_data.MagData method)}

\begin{fulllineitems}
\phantomsection\label{mag_data:mag_data.MagData._find_bvac_times}\pysiglinewithargsret{\bfcode{\_find\_bvac\_times}}{}{}
Find the start and end time of
the Bvac \textgreater{} 1.5T
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
False if there is no Bvac
True otherwise

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{NBIData}
\label{nbi_data:nbidata}\label{nbi_data:module-nbi_data}\label{nbi_data::doc}\index{nbi\_data (module)}
Class to read in NBI data and store start \& end of NBI power
\index{NBIData (class in nbi\_data)}

\begin{fulllineitems}
\phantomsection\label{nbi_data:nbi_data.NBIData}\pysiglinewithargsret{\strong{class }\code{nbi\_data.}\bfcode{NBIData}}{\emph{constants}}{}
Bases: \code{object}
\index{NBI\_MIN\_POWER (nbi\_data.NBIData attribute)}

\begin{fulllineitems}
\phantomsection\label{nbi_data:nbi_data.NBIData.NBI_MIN_POWER}\pysigline{\bfcode{NBI\_MIN\_POWER}\strong{ = 3.5}}
\end{fulllineitems}

\index{read\_data() (nbi\_data.NBIData method)}

\begin{fulllineitems}
\phantomsection\label{nbi_data:nbi_data.NBIData.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{shot\_no}}{}
Read in nbi data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- shot number

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{PelletData}
\label{pellet_data:pelletdata}\label{pellet_data:module-pellet_data}\label{pellet_data::doc}\index{pellet\_data (module)}
Class to read and store time of pellets.

Expecting to use PL/PTRK-ANA\textless{}PKM signal, which has a data point
per pellet, the value of which is the mass of the pellet in mg,
measured using a microwave cavity.
\index{PelletData (class in pellet\_data)}

\begin{fulllineitems}
\phantomsection\label{pellet_data:pellet_data.PelletData}\pysiglinewithargsret{\strong{class }\code{pellet\_data.}\bfcode{PelletData}}{\emph{constants}}{}
Bases: \code{object}
\index{PELLET\_THRESHOLD (pellet\_data.PelletData attribute)}

\begin{fulllineitems}
\phantomsection\label{pellet_data:pellet_data.PelletData.PELLET_THRESHOLD}\pysigline{\bfcode{PELLET\_THRESHOLD}\strong{ = 4.0}}
\end{fulllineitems}

\index{read\_data() (pellet\_data.PelletData method)}

\begin{fulllineitems}
\phantomsection\label{pellet_data:pellet_data.PelletData.read_data}\pysiglinewithargsret{\bfcode{read\_data}}{\emph{shot\_no}}{}
Read in pellets data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{shot\_no}} -- Shot number

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Canvas}
\label{canvas:module-canvas}\label{canvas:canvas}\label{canvas::doc}\index{canvas (module)}\index{Canvas (class in canvas)}

\begin{fulllineitems}
\phantomsection\label{canvas:canvas.Canvas}\pysiglinewithargsret{\strong{class }\code{canvas.}\bfcode{Canvas}}{\emph{parent=None}}{}
Bases: \code{matplotlib.backends.backend\_qt4agg.FigureCanvasQTAgg}

CLASS used to convert widget into a matplotlib figure

contains mouse event (right click) that returns (xs,yx) when click is in axes
\index{signal (canvas.Canvas attribute)}

\begin{fulllineitems}
\phantomsection\label{canvas:canvas.Canvas.signal}\pysigline{\bfcode{signal}}
\end{fulllineitems}


\end{fulllineitems}

\index{bin\_() (in module canvas)}

\begin{fulllineitems}
\phantomsection\label{canvas:canvas.bin_}\pysiglinewithargsret{\code{canvas.}\bfcode{bin\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}

\index{hex\_() (in module canvas)}

\begin{fulllineitems}
\phantomsection\label{canvas:canvas.hex_}\pysiglinewithargsret{\code{canvas.}\bfcode{hex\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}

\index{oct\_() (in module canvas)}

\begin{fulllineitems}
\phantomsection\label{canvas:canvas.oct_}\pysiglinewithargsret{\code{canvas.}\bfcode{oct\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}



\section{SupportClasses}
\label{support_classes:module-support_classes}\label{support_classes:supportclasses}\label{support_classes::doc}\index{support\_classes (module)}\index{MyLocator (class in support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.MyLocator}\pysigline{\strong{class }\code{support\_classes.}\bfcode{MyLocator}}
Bases: \code{matplotlib.ticker.AutoLocator}
\index{view\_limits() (support\_classes.MyLocator method)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.MyLocator.view_limits}\pysiglinewithargsret{\bfcode{view\_limits}}{\emph{vmin}, \emph{vmax}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{LineEdit (class in support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.LineEdit}\pysigline{\strong{class }\code{support\_classes.}\bfcode{LineEdit}}
Bases: \code{PyQt4.QtGui.QLineEdit}

inherit from QLineEdit
we use super so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).

uses mouse press event and emit signal when clicked
\index{signal\_evoke\_kb (support\_classes.LineEdit attribute)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.LineEdit.signal_evoke_kb}\pysigline{\bfcode{signal\_evoke\_kb}}
\end{fulllineitems}

\index{mousePressEvent() (support\_classes.LineEdit method)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.LineEdit.mousePressEvent}\pysiglinewithargsret{\bfcode{mousePressEvent}}{\emph{QMouseEvent}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Key (class in support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.Key}\pysiglinewithargsret{\strong{class }\code{support\_classes.}\bfcode{Key}}{\emph{name}, \emph{event}, \emph{receiver}}{}
Bases: \code{PyQt4.QtGui.QPushButton}

\end{fulllineitems}

\index{KeyBoard (class in support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.KeyBoard}\pysiglinewithargsret{\strong{class }\code{support\_classes.}\bfcode{KeyBoard}}{\emph{receiver}}{}
Bases: \code{PyQt4.QtGui.QWidget}

Keyboard class is a new widget that pops up when the QlineEdit is clicked
to show keys that can be pressed to write in the QlineEdit defining the corrections the users wants to apply
\index{apply\_pressed\_signal (support\_classes.KeyBoard attribute)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.KeyBoard.apply_pressed_signal}\pysigline{\bfcode{apply\_pressed\_signal}}
\end{fulllineitems}

\index{key\_pressed() (support\_classes.KeyBoard method)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.KeyBoard.key_pressed}\pysiglinewithargsret{\bfcode{key\_pressed}}{}{}
\end{fulllineitems}

\index{apply\_pressed() (support\_classes.KeyBoard method)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.KeyBoard.apply_pressed}\pysiglinewithargsret{\bfcode{apply\_pressed}}{}{}
\end{fulllineitems}

\index{keyPressEvent() (support\_classes.KeyBoard method)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.KeyBoard.keyPressEvent}\pysiglinewithargsret{\bfcode{keyPressEvent}}{\emph{evt}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{bin\_() (in module support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.bin_}\pysiglinewithargsret{\code{support\_classes.}\bfcode{bin\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}

\index{hex\_() (in module support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.hex_}\pysiglinewithargsret{\code{support\_classes.}\bfcode{hex\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}

\index{oct\_() (in module support\_classes)}

\begin{fulllineitems}
\phantomsection\label{support_classes:support_classes.oct_}\pysiglinewithargsret{\code{support\_classes.}\bfcode{oct\_}}{\emph{QTextStream}}{{ $\rightarrow$ QTextStream}}
\end{fulllineitems}



\section{Formatters}
\label{custom_formatters:module-custom_formatters}\label{custom_formatters:formatters}\label{custom_formatters::doc}\index{custom\_formatters (module)}\index{MyFormatter (class in custom\_formatters)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter}\pysiglinewithargsret{\strong{class }\code{custom\_formatters.}\bfcode{MyFormatter}}{\emph{fmt=None}, \emph{datefmt=None}, \emph{style='\%'}}{}
Bases: \code{logging.Formatter}

class to handle the logging formatting
\index{PURPLE (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.PURPLE}\pysigline{\bfcode{PURPLE}\strong{ = `\textbackslash{}x1b{[}95m'}}
\end{fulllineitems}

\index{CYAN (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.CYAN}\pysigline{\bfcode{CYAN}\strong{ = `\textbackslash{}x1b{[}96m'}}
\end{fulllineitems}

\index{DARKCYAN (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.DARKCYAN}\pysigline{\bfcode{DARKCYAN}\strong{ = `\textbackslash{}x1b{[}36m'}}
\end{fulllineitems}

\index{BLUE (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.BLUE}\pysigline{\bfcode{BLUE}\strong{ = `\textbackslash{}x1b{[}94m'}}
\end{fulllineitems}

\index{GREEN (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.GREEN}\pysigline{\bfcode{GREEN}\strong{ = `\textbackslash{}x1b{[}92m'}}
\end{fulllineitems}

\index{YELLOW (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.YELLOW}\pysigline{\bfcode{YELLOW}\strong{ = `\textbackslash{}x1b{[}93m'}}
\end{fulllineitems}

\index{RED (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.RED}\pysigline{\bfcode{RED}\strong{ = `\textbackslash{}x1b{[}91m'}}
\end{fulllineitems}

\index{BOLD (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.BOLD}\pysigline{\bfcode{BOLD}\strong{ = `\textbackslash{}x1b{[}1m'}}
\end{fulllineitems}

\index{UNDERLINE (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.UNDERLINE}\pysigline{\bfcode{UNDERLINE}\strong{ = `\textbackslash{}x1b{[}4m'}}
\end{fulllineitems}

\index{END (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.END}\pysigline{\bfcode{END}\strong{ = `\textbackslash{}x1b{[}0m'}}
\end{fulllineitems}

\index{err\_fmt (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.err_fmt}\pysigline{\bfcode{err\_fmt}\strong{ = `{[}\textbackslash{}x1b{[}91m\%(levelname)-5s\textbackslash{}x1b{[}0m{]} \textbackslash{}x1b{[}91m\%(message)s\textbackslash{}x1b{[}0m'}}
\end{fulllineitems}

\index{dbg\_fmt (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.dbg_fmt}\pysigline{\bfcode{dbg\_fmt}\strong{ = `{[}\textbackslash{}x1b{[}36m\%(levelname)-4s\textbackslash{}x1b{[}0m{]} {[}\textbackslash{}x1b{[}36m\%(filename)s\textbackslash{}x1b{[}0m:\textbackslash{}x1b{[}36m\%(lineno)d\textbackslash{}x1b{[}0m{]} \textbackslash{}x1b{[}36m\%(message)s\textbackslash{}x1b{[}0m'}}
\end{fulllineitems}

\index{dbgplus\_fmt (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.dbgplus_fmt}\pysigline{\bfcode{dbgplus\_fmt}\strong{ = `{[}\textbackslash{}x1b{[}92m\%(levelname)-8s\textbackslash{}x1b{[}0m{]} (\textbackslash{}x1b{[}92m\%(filename)s:\%(lineno)d\textbackslash{}x1b{[}0m) \textbackslash{}x1b{[}92m\%(message)s\textbackslash{}x1b{[}0m'}}
\end{fulllineitems}

\index{info\_fmt (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.info_fmt}\pysigline{\bfcode{info\_fmt}\strong{ = `{[}\textbackslash{}x1b{[}94m\%(levelname)-4s\textbackslash{}x1b{[}0m{]} \textbackslash{}x1b{[}94m\%(message)s\textbackslash{}x1b{[}0m'}}
\end{fulllineitems}

\index{warn\_fmt (custom\_formatters.MyFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.warn_fmt}\pysigline{\bfcode{warn\_fmt}\strong{ = `{[}\textbackslash{}x1b{[}93m\%(levelname)-7s\textbackslash{}x1b{[}0m{]} \textbackslash{}x1b{[}93m\%(message)s\textbackslash{}x1b{[}0m'}}
\end{fulllineitems}

\index{format() (custom\_formatters.MyFormatter method)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.MyFormatter.format}\pysiglinewithargsret{\bfcode{format}}{\emph{record}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{QPlainTextEditLogger (class in custom\_formatters)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.QPlainTextEditLogger}\pysiglinewithargsret{\strong{class }\code{custom\_formatters.}\bfcode{QPlainTextEditLogger}}{\emph{parent}}{}
Bases: \code{logging.Handler}

class that defines a handler to write logging message inside the GUI
\index{emit() (custom\_formatters.QPlainTextEditLogger method)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.QPlainTextEditLogger.emit}\pysiglinewithargsret{\bfcode{emit}}{\emph{record}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{HTMLFormatter (class in custom\_formatters)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.HTMLFormatter}\pysiglinewithargsret{\strong{class }\code{custom\_formatters.}\bfcode{HTMLFormatter}}{\emph{fmt=None}, \emph{datefmt=None}, \emph{style='\%'}}{}
Bases: \code{logging.Formatter}
\index{FORMATS (custom\_formatters.HTMLFormatter attribute)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.HTMLFormatter.FORMATS}\pysigline{\bfcode{FORMATS}\strong{ = \{40: (`{[}\%(levelname)-5s{]} \%(message)s', \textless{}PyQt4.QtGui.QColor object at 0x7f2892e42e48\textgreater{}), 10: (`{[}\%(levelname)-5s{]} {[}\%(filename)s:\%(lineno)d{]} \%(message)s', `green'), 20: (`{[}\%(levelname)-4s{]} \%(message)s', `\#0000FF'), 5: (`\%(levelname)s - {[}\%(filename)s:\%(lineno)d{]} - \%(message)s', \textless{}PyQt4.QtGui.QColor object at 0x7f2892e42f28\textgreater{}), 30: (`\%(levelname)s - \%(message)s', \textless{}PyQt4.QtGui.QColor object at 0x7f2892e42eb8\textgreater{})\}}}
\end{fulllineitems}

\index{format() (custom\_formatters.HTMLFormatter method)}

\begin{fulllineitems}
\phantomsection\label{custom_formatters:custom_formatters.HTMLFormatter.format}\pysiglinewithargsret{\bfcode{format}}{\emph{record}}{}
\end{fulllineitems}


\end{fulllineitems}



\section{CORMAT\_GUI}
\label{CORMAT_GUI:cormat-gui}\label{CORMAT_GUI:module-CORMAT_GUI}\label{CORMAT_GUI::doc}\index{CORMAT\_GUI (module)}\index{\_fromUtf8() (in module CORMAT\_GUI)}

\begin{fulllineitems}
\phantomsection\label{CORMAT_GUI:CORMAT_GUI._fromUtf8}\pysiglinewithargsret{\code{CORMAT\_GUI.}\bfcode{\_fromUtf8}}{\emph{s}}{}
\end{fulllineitems}

\index{\_translate() (in module CORMAT\_GUI)}

\begin{fulllineitems}
\phantomsection\label{CORMAT_GUI:CORMAT_GUI._translate}\pysiglinewithargsret{\code{CORMAT\_GUI.}\bfcode{\_translate}}{\emph{context}, \emph{text}, \emph{disambig}}{}
\end{fulllineitems}

\index{Ui\_CORMAT\_py (class in CORMAT\_GUI)}

\begin{fulllineitems}
\phantomsection\label{CORMAT_GUI:CORMAT_GUI.Ui_CORMAT_py}\pysigline{\strong{class }\code{CORMAT\_GUI.}\bfcode{Ui\_CORMAT\_py}}
Bases: \code{object}
\index{setupUi() (CORMAT\_GUI.Ui\_CORMAT\_py method)}

\begin{fulllineitems}
\phantomsection\label{CORMAT_GUI:CORMAT_GUI.Ui_CORMAT_py.setupUi}\pysiglinewithargsret{\bfcode{setupUi}}{\emph{CORMAT\_py}}{}
\end{fulllineitems}

\index{retranslateUi() (CORMAT\_GUI.Ui\_CORMAT\_py method)}

\begin{fulllineitems}
\phantomsection\label{CORMAT_GUI:CORMAT_GUI.Ui_CORMAT_py.retranslateUi}\pysiglinewithargsret{\bfcode{retranslateUi}}{\emph{CORMAT\_py}}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{canvas}}, \pageref{canvas:module-canvas}
\item {\texttt{consts}}, \pageref{consts:module-consts}
\item {\texttt{CORMAT\_GUI}}, \pageref{CORMAT_GUI:module-CORMAT_GUI}
\item {\texttt{Cormat\_main}}, \pageref{Cormat_main:module-Cormat_main}
\item {\texttt{custom\_formatters}}, \pageref{custom_formatters:module-custom_formatters}
\indexspace
\bigletter{e}
\item {\texttt{elms\_data}}, \pageref{elms_data:module-elms_data}
\indexspace
\bigletter{f}
\item {\texttt{find\_disruption}}, \pageref{find_disruption:module-find_disruption}
\indexspace
\bigletter{h}
\item {\texttt{hrts\_data}}, \pageref{hrts_data:module-hrts_data}
\indexspace
\bigletter{k}
\item {\texttt{kg1\_ppf\_data}}, \pageref{kg1_ppf_data:module-kg1_ppf_data}
\item {\texttt{kg4\_data}}, \pageref{kg4_data:module-kg4_data}
\indexspace
\bigletter{l}
\item {\texttt{library}}, \pageref{library:module-library}
\item {\texttt{lidar\_data}}, \pageref{lidar_data:module-lidar_data}
\indexspace
\bigletter{m}
\item {\texttt{mag\_data}}, \pageref{mag_data:module-mag_data}
\indexspace
\bigletter{n}
\item {\texttt{nbi\_data}}, \pageref{nbi_data:module-nbi_data}
\indexspace
\bigletter{p}
\item {\texttt{pellet\_data}}, \pageref{pellet_data:module-pellet_data}
\item {\texttt{ppf\_write}}, \pageref{ppf_write:module-ppf_write}
\indexspace
\bigletter{s}
\item {\texttt{signal\_amp}}, \pageref{signal_amp:module-signal_amp}
\item {\texttt{signal\_base}}, \pageref{signal_base:module-signal_base}
\item {\texttt{signal\_kg1}}, \pageref{signal_kg1:module-signal_kg1}
\item {\texttt{status\_flag}}, \pageref{status_flag:module-status_flag}
\item {\texttt{support\_classes}}, \pageref{support_classes:module-support_classes}
\indexspace
\bigletter{w}
\item {\texttt{wv\_denoise}}, \pageref{wv_denoise:module-wv_denoise}
\item {\texttt{wv\_get\_background}}, \pageref{wv_get_background:module-wv_get_background}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
